#include<stdio.h>
#include<string.h>
#include<math.h>
#include<ctype.h>
#include<stdlib.h>
int main()
{
   
    return 0;
}
/*
 一.关于存储单位
 1.位bit
  bit就是位，是计算机表示数据的最小单位
 2.byte字节
   一个字节包含八个比特位 1byte=8bit;
 3.字符
  char 1byte
  short int 2byte
  int 4byte
  float 4byte
  double 8byte
  在实验步骤四中将八位放入一个字节中，需要采用unsinged char 
  unsigned char 0-255
  char -128-127
  回想字节存储最高位：若为有符号类型 如char 最高位存储为符号位 0代表正1代表负
  即char 类型真正表示数值的只有七位，因此在题目情境下存储编码无正负且为8位，需要使用unsinge char 
二.关于位运算
  hc=(hc<<1)|(*pc-'0')?
  <<左移运算符 向左移动一位 右边补0
  >>右移运算符  算术右移：左边补原符号位 逻辑右移：左边补0
  对int为算数右移，对unsinged为逻辑右移
  当hc中存储比特个数小于8时，将hc按比特位左移一位，右边补0(while(codelen++<8)hc=(hc<<1));
  hc=(hc<<1)|(*pc-'0')即代表着将hc左移一位之后，空出的最后一位用读到的huffman编码赋值  0|0=0,0|1=1;
  当存够八位时，就是一个完整的unsigned char 
三.关于稳定排序与不稳定排序
稳定排序：插入排序，冒泡排序，归并排序，基数排序
不稳定排序：快速排序，选择排序，希尔排序，堆排序
稳定排序(来源于百度百科):待排序的记录序列中可能存在两个或两个以上关键字相等的记录，若排序前的序列中Ri领先于Rj
若在排序后的序列中Ri仍然领先于Rj,则称所用的方法是稳定的
四.文件读写头问题
当利用文件指针读取一次文件之后，文件指针就会停留在文件末尾的结束符\0,这时要想重新读取文件就需要进行文件指针复位
比较简单的方法是:重新定义一个文件指针再次从头开始
*/
/*
对于思路的整理
本次作业实验题模拟利用huffman编码进行文件压缩
huffman编码本质上是一种变长编码，出现频率高的字符编码位数少，出现频率低的字符编码长度长
而编码位数的长短即为通过huffman树来实现的huffman树实现了最小带权路径长度，如果对经过的每个节点给与0与1的赋值
就可以保证所有字符的huffman编码总长度要小于原来，达到压缩效果
定义：带权路径长度
 若给具有m个叶结点的二叉树的每个叶子节点赋予一个权值，则带权路径长度定义为所有叶节点的权值与路径长度乘积的总和
 给定一组权值，最小带权路径的二叉树即为huffman树(编码总长度最短)
 huffman树：权值越大的叶节点离根节点越近，无度为1的结点(二叉全满)
1.    对正文文件中字符(换行字符'\n'除外，不统计)按出现次数（即频率）进行统计。Ccount[128]
2.    依据字符频率生成相应的Huffman树（未出现的字符不生成）。
      1．依据数组Ccout中出现次数不为0的（ 即Ccount[i]>0）项，构造出树林F={T0, T1, ¼, Tm}，初始时Ti(0≤i≤m)为只有一个根结构的树，且根结点(叶结点)的权值为相应字符的出现次数的二叉树（每棵树结点的类型为struct tnode，其成员c为字符，weight为树节点权值）：
      2．对树林F中每棵树按其根结点的权值由小至大进行排序（排序时，当权值weight相同时，字符c小的排在前面），得到一个有序树林F
      3．while 树个数>1 in F
       a)   将F中T0和T1作为左、右子树合并成为一棵新的二叉树T’，并令T’->weight= T0->weight+ T1->wei
       b)   删除T0和T1 from F，同时将T’加入F。要求加入T’后F仍然有序。若F中有树根结点权值与T’相同，则T’应加入到其后
      4．Root = T0 （Root为Huffman树的根结点指针。循环结束时，F中只有一个T0）
3.    依据Huffman树生成相应字符的Huffman编码。
      可编写一个按前序遍历方法对根节点为Root的树进行遍历的递归函数，并在遍历过程中用一个字符串来记录遍历节点时从根节点到当前节点的路径（经过的边），
      经过左边时记录为’0’，经过右边时记录为’1’；当遍历节点为叶节点时，将对应路径串存放到相应的HCode数组中，即执行strcpy(HCode[p->c],路径串)。
4.    依据字符Huffman编码压缩文件（即将源文件字符按照其Huffman编码输出）
      1）根据输入字符序列将其Huffman编码串连接成一个（由0、1字符组成的）串；
      2）然后依次读取该串中字符，依次放入到一个字节的相应位上；
      3）若放满一个字节（即8位），可输出该字节；剩余的字符开始放入到下一个字节中；
      4）重复步骤2和3，直到串中所有字符处理完。
      说明：
      1．当遇到源文本文件输入结束时，应将输入结束符的Huffman码放到Huffman编码串最后，即将编码串HCode[0]放到Huffman编码串最后。
      2．在处理完成所有Huffman编码串时（如上述算法结束时），处理源文本最后一个字符（文件结束符）Huffman编码串（其编码串为“01001010”）时，可能出现如下情况：其子串”010”位于前一个字节中输出，而子串“01010”位于另（最后）一个字节的右5位中，需要将这5位左移至左端的头，最后3位补0，然后再输出最后一个字节。

说明：
1.    只对文件中出现的字符生成Huffman树，注意：一定不要处理\n，即不要为其生成Huffman编码。
2.    采用ASCII码值为0的字符作为压缩文件的结束符（即可将其出现次数设为1来参与编码）。
3.    在生成Huffman树前，初始在对字符频率权重进行（由小至大）排序时，频率相同的字符ASCII编码值小的在前；新生成的权重节点插入到有序权重序列中时，若出现相同权重，则将新生成的权重节点插入到原有相同权重节点之后（采用稳定排序）。
4.   在生成Huffman树时，权重节点在前的作为左孩子节点，权重节点在后的作为右孩子节点。
5.    遍历Huffman树生成字符Huffman码时，左边为0右边为1。
6.   源文件是文本文件，字符采用ASCII编码，每个字符占8个二进制位；而采用Huffman编码后，高频字符编码长度较短（小于8位），因此最后输出时需要使用C语言中的位运算将字符的Huffman码依次输出到每个字节中。
*/