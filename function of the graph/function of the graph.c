/*1.图——由顶点集合(记为V)与边集合(记为E)组成
 *无向图：顶点之间的连线不画箭头 (vi,vj)属于E，则(vj,vi)属于E
 *有向图：顶点之间的连线画箭头，(vi,vj)是顶点的有序偶对
 *网（络）：与边有关的数据称为权，边上带权的图称为网络
 * 2.顶点的度：依附于顶点vi的边的数目TD(vi)
 * 对于有向图而言，细分为出度(OD(vi))与入度(ID(vi)) TD(vi)=OD(vi)+ID(vi)
 * 结论一：具有n个顶点的无向图最多有n(n-1)/2(C n 2)条边
 * 结论二：具有n个结点的有向图最多有n(n-1)条边
 * 结论三：顶点度之和等于二倍边数
 * 边的数目达到最大的图称为完全图，边的数目达到或接近最大的图称为稠密图，否则为稀疏图
 * 3.路径和路径长度：顶点vx到vy之间有路径P(vx,vy)的充分必要条件：存在顶点序列vx,vi1,vi2...vy（不一定是直接相连）
 * 环：出发点与终止点不相同 简单路径：顶点不重复出现
 * 不带权的图的路径长度：路径上所经过的边的数目 带权的图的路径长度：路径上经过的边上的权值之和
 * 4.无向图的连通：无向图中任意两个顶点都连通
 * 有向图的连通：定义有向图中顶点的连通：vi->vj有路径，vj->vi也有路径,任意两个顶点都连通的有向图称为强连通
 * 5.生成树：包含具有n个顶点的连通图的全部n个顶点，仅包含n-1条边的极小连通子图
 *
 * n个顶点的连通图采用邻接矩阵表示时，该矩阵至少有2(n-1)个非0元素
 * 
 * 图的存储方法：
 * 1.邻接矩阵存储：采用两个数组存储一个图
 * （1）.一维数组vertex[0...n-1]存放途中所有项的数据信息
 * （2）.二维数组A[0...n-1][0...n-1]存放途中所有顶点之间关系的信息（该数组被称为邻接矩阵）
 * A[i][j]=1 顶点i->j有边 A[i][j]=0顶点i->j无边
 * or A[i][j]=wij（权值）
 * 无向图的邻接矩阵一定是对称矩阵，不带权的有向图的邻接矩阵一般是稀疏矩阵（空间浪费较大）
 * 无向图第i行或第i列的非0元素为第i个顶点的度数
 * 有向图第i行的非0个数为第i个顶点的出度，第i列的非0个数为第i个顶点的入度
 *
 * 2.邻接表存储：建立n个线性链表存储 顶点节点之间线性存储，关系链式存储(顶点结点->边结点->边结点)
 * 每个链表的前面设置一个头节点，用来存放一个顶点的数据信息，称之为顶点结点 构造为vertex link
 * n个头节点之间为数组结构
 * 第i个链表中的每一个链结点（边结点）表示以第i个顶点为出发点的一条边 构造为 adjvex weight link
 * adjvex存放以第i个顶点为出发点的一条边的另一端点在头节点数组中的位置
 *（1）无向图的第i个链表中边结点的个数是第i个顶点的度数
 *（2）有向图->出度
 *（3）无向图的边结点个数一定是偶数，边结点个数为奇数一定是有向图
 * 逆邻接表就是将原图中箭头方向都反过来再做邻接表
 * //实现邻接表
typedef struct edge{//定义边结点
    int adjvex;
    int weight;
    struct edge*link;
}ELink,*Elinkptr;
typedef struct ver{//定义顶点类型
    int vertex;
    struct edge*link;
}VLink,*Vlinkptr;
VLink G[MaxV];//顶点线性表
//实现邻接矩阵
int vettex[100];//定点信息数组
typedef struct _edge{//定义边类型
    int weight;
}Edge;
Edge Gg[MaxV][MaxV];

  6.图的遍历
  从图中某个指定的顶点出发，按照某一原则对图中的所有顶点访问一次且仅访问一次
  一.深度优先遍历 类似于二叉树前序遍历 递归过程
  从图中某个指定的顶点v出发,先访问v,然后从顶点v未被访问的一个邻接点出发，继续进行深度优先遍历
  考察图的深度优先遍历的序列的题目，先画好图，再看选项 看选项里的起点和先走的分支 之后比对
  二.广度优先遍历 类似于二叉树层序遍历
  从图中某个指定的顶点v出发，先访问顶点v,然后依次访问顶点v各个未被访问的邻接点，再从邻接点出发依次向下
  如果图中有n个结点e条边
  深度优先与广度优先算法时间复杂度相同均为O(n+e)
  DFS更适用于以找到目标为主要目的的情况
  BFS更适合不断扩大遍历范围找到最优解

  生成树：n个节点，n-1条边，无回路且连通，是一棵树，一般情况下生成树不唯一
  最小生成树：总权值最小的生成树
  MST性质：假设N=(V,{E})是一个联通网，U是顶点V的一个非空子集，如果u属于U,v属于V-U（差集）
  (u,v)是一条具有最小权值的边，则必定存在一棵包含边(u,v)的最小生成树
  prim算法——取决于采用的数据结构 对稠密图好一些
  从图中一个起点a开始，把a加入U集合，然后从与a有关联的边中寻找权重最小的那条边，并且该边的终点在V-U中
  ，将b加入集合U，输出边(a,b)的信息，然后再寻找与a,b关联的边中权重最小的...直到所有顶点都加入集合U
   Kruskal算法：贪心策略 O(nlogn)(n为边数) 对稀疏图有优势
   将边按照权值从大到小的顺序加入到图中，且保证添加的过程中不会形成环，重复直到连接所有顶点
 * 其中，由Kruskal可以看出，任意连通图中，假设没有相同权值的边存在，则权值最小的边一定在最小生成树中
 * 权值最大的边不一定
 *
 * 最短路径问题
 * 单源最短路径的Dijkstra迪杰斯特拉算法：贪心思想
 * 第一步选定源点，设置集合A用来存放已经求出最短路径的点，B用来存放还未计算出最短路径的点（这些点的距离初始值为无穷）
 * 初始状态下A集合中只有源点（距离为0），从源点开始，更新和源点邻接的所有点的距离，选出此时B集合中距离源点最短的点，加入到A集合中，更新与该点邻接点距离值（减小）
 * 这里更新距离的值依赖于之前加入A集合的点
 * 不断进行直到B集合中只剩下一个点，直接加入A集合
 *
 * 最短路径与最小生成树的区别
 * 最小生成树：prim或kruskal
 * 最短路径：kjstra(不允许出现负权边)
 * 最小生成树：整个拓扑图全局的路径之和最小，全局最优
 * 最短路径：从源点到达各个点的最短 不一定是全局最优
 * 
 * 
 * AOV网与拓扑排序
 * 以顶点表示活动，以有向边表示活动之间的优先关系的有向图称为AOV网 activity on vertex network
 * 判断工程能否正常进行：即判断对应的AOV网中是否有回路，检测回路的方法:拓扑排序
 * 拓扑排序性质：
 * 1.AOV网中顶点i优于顶点j则在该序列中仍然满足顶点i优于顶点j(前驱、后继的概念)
 * 2.在AOV网中，顶点i与顶点j不存在优先关系，则在序列中建立优先关系
 * 3.若能构造出这样的拓扑序列，包含AOV网的全部节点则说明AOV网中没有回路
 * 4.拓扑排序不唯一
 * 拓扑排序构造方法：
 * 1.从AOV网中任意选择一个没有前驱的节点
 * 2.从AOV网中去掉该顶点以及该顶点为出发点的所有边
 * 3.重复上述过程直到AOV网中所有顶点都被去掉
 * 4.若到最后AOV网中还有节点但不存在入度为0的顶点则说明有回路
 * //拓扑排序的算法实现 O(n+e)
*
 *首先建立一个入度为0的顶点栈，将网中所有入度为0的顶点分别进栈
 *当栈不为空时，反复执行以下操作：
 * 1.从顶点栈中退出一个顶点，并输出它
 * 2.从AOV网中删去该顶点以及它发出的所有边，并分别将这些边的终点的入度减1，终点入度为0进栈
 * 3.输出顶点的个数小于APV网中顶点个数，则存在回路
 *
 * AOE网与关键路径
 * AOE activity on edge 带权的有向无环的图，顶点表示事件，有向边表示活动，边上权值表示活动持续时间
 * AOE网中只有一个入度为0的点，称为源点，只有一个出度为0的点，称之为终点
 * 只有当某个顶点代表的事件发生之后该顶点引发的活动才能开始，进入某事件所有边代表的活动都已完成，该事件才能发生
 * 关键路径：从源点到终点具有最大长度的路径，关键路径上的活动为关键活动
 * 关键路径的长度（路径边上的权值之和）为完成整个工程的最短时间，关键路径长度变化影响整个工程进度，其他非关键活动影响小
 * 事件k的最早发生时间：从源点到事件k的最大路径长度
 * 事件k的最晚发生时间：从事件k发出的所有活动的终止事件的最迟发生时间（从后向前反推）
 * 若活动ai的前驱事件为k，则事件k的最早发生时间即为ai的最早开始时间（e[i]），k最晚发生时间为ai最晚开始时间(l[i])
 * 当e[i]=l[i]时说明为关键活动
 * */
/*基础的图，从存储方式谈起
 * 1.邻接矩阵
 * 2.邻接表
 */
//作业题中遇到的都是无向图
/*
 * 先谈一谈邻接矩阵
 */
 //若图中边是无权重的,把边赋值为1表示连通,有权重则连通的边值赋为权重，不连通的边赋无穷大
 //建立一个邻接矩阵 (INT_MAX是C语言定义的int类型最大值，可以当作无穷大使用)
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#define MaxValue INT_MAX
#define MinValue INT_MIN
#define MAX 100
//依次输入带权无向图的n个顶点，和e条边(起点，终点，权值)，时间复杂度建立邻接矩阵结构 O(n^2+e)
void ADJmatrix(int matrix[][MAX],int n,int e)
{
    int i,j,ver,adj,weight;
    for(i=0;i<n;i++){
        for(j=0;j<n;j++){
            matrix[i][j]=MaxValue;//初始赋权值为无穷大
        }
    }
    for(int k=0;k<e;k++){
        scanf("%d%d%d",&ver,&adj,&weight);
        matrix[ver][adj]=weight;matrix[adj][ver]=weight;
    }
}
//无权无向图
void ADJmatrix2(int matrix[][MAX],int n,int e)
{
   for(int i=0;i<n;i++){
       for(int j=0;j<n;j++){
           matrix[i][j]=0;
       }
   }
   for(int k=0;k<e;k++){
       int ver,adj;
       scanf("%d%d",&ver,&adj);
       matrix[ver][adj]=1;
       matrix[adj][ver]=1;
   }
}
//邻接矩阵的深度优先遍历（DFS）
int visited[MAX]={0};
int n;//节点个数
int matrix[MAX][MAX];
int DFS(int ver)//ver为起始顶点
{
    memset(visited,0,sizeof (visited));
    printf("%d ",ver);
    visited[ver]=1;
    for(int i=0;i<n;i++){
        if(matrix[ver][i]&&!visited[i])
            DFS(i);
    }
}
//邻接矩阵的广度优先遍历(BFS)用队列实现
void BFS(int ver)
{
    memset(visited,0,sizeof (visited));
    int queue[MAX]={0};
    int front=0,rear=0;
    queue[rear++]=ver;
    while(front<=rear){
        int tmp=queue[front++];
        if(!visited[tmp]){
            printf("%d ",tmp);
            visited[tmp]=1;
            for(int i=0;i<n;i++){
                if(matrix[tmp][i]&&!visited[i])
                    queue[rear++]=i;
            }
        }
    }
}
//邻接表
//邻接表建立
